(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 2.0.2
(function() {
  var Bottleneck, MIDDLE_PRIORITY, NB_PRIORITIES,
    slice = [].slice;

  NB_PRIORITIES = 10;

  MIDDLE_PRIORITY = 5;

  Bottleneck = (function() {
    var e;

    class Bottleneck {
      constructor(maxNb = 0, minTime = 0, highWater = -1, strategy = Bottleneck.prototype.strategy.LEAK, rejectOnDrop = false) {
        this.submit = this.submit.bind(this);
        this.submitPriority = this.submitPriority.bind(this);
        this.schedulePriority = this.schedulePriority.bind(this);
        this.maxNb = maxNb;
        this.minTime = minTime;
        this.highWater = highWater;
        this.strategy = strategy;
        this.rejectOnDrop = rejectOnDrop;
        this._nextRequest = Date.now();
        this._nbRunning = 0;
        this._queues = this._makeQueues();
        this._running = {};
        this._nextIndex = 0;
        this._unblockTime = 0;
        this.penalty = (15 * this.minTime) || 5000;
        this.interrupt = false;
        this.reservoir = null;
        this.limiter = null;
        this.events = {};
      }

      _trigger(name, args) {
        if (this.rejectOnDrop && name === "dropped") {
          args[0].cb.apply({}, [new Bottleneck.prototype.BottleneckError("This job has been dropped by Bottleneck")]);
        }
        return setTimeout((() => {
          var ref;
          return (ref = this.events[name]) != null ? ref.forEach(function(e) {
            return e.apply({}, args);
          }) : void 0;
        }), 0);
      }

      _makeQueues() {
        var i, j, ref, results;
        results = [];
        for (i = j = 1, ref = NB_PRIORITIES; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
          results.push(new Bottleneck.prototype.DLList());
        }
        return results;
      }

      chain(limiter) {
        this.limiter = limiter;
        return this;
      }

      isBlocked() {
        return this._unblockTime >= Date.now();
      }

      _sanitizePriority(priority) {
        var sProperty;
        sProperty = ~~priority !== priority ? MIDDLE_PRIORITY : priority;
        if (sProperty < 0) {
          return 0;
        } else if (sProperty > NB_PRIORITIES - 1) {
          return NB_PRIORITIES - 1;
        } else {
          return sProperty;
        }
      }

      _find(arr, fn) {
        var ref;
        return (ref = (function() {
          var i, j, len, x;
          for (i = j = 0, len = arr.length; j < len; i = ++j) {
            x = arr[i];
            if (fn(x)) {
              return x;
            }
          }
        })()) != null ? ref : [];
      }

      nbQueued(priority) {
        if (priority != null) {
          return this._queues[this._sanitizePriority(priority)].length;
        } else {
          return this._queues.reduce((function(a, b) {
            return a + b.length;
          }), 0);
        }
      }

      nbRunning() {
        return this._nbRunning;
      }

      _getFirst(arr) {
        return this._find(arr, function(x) {
          return x.length > 0;
        });
      }

      _conditionsCheck() {
        return (this.nbRunning() < this.maxNb || this.maxNb <= 0) && ((this.reservoir == null) || this.reservoir > 0);
      }

      check() {
        return this._conditionsCheck() && (this._nextRequest - Date.now()) <= 0;
      }

      _tryToRun() {
        var done, index, next, queued, wait;
        if (this._conditionsCheck() && (queued = this.nbQueued()) > 0) {
          this._nbRunning++;
          if (this.reservoir != null) {
            this.reservoir--;
          }
          wait = Math.max(this._nextRequest - Date.now(), 0);
          this._nextRequest = Date.now() + wait + this.minTime;
          next = (this._getFirst(this._queues)).shift();
          if (queued === 1) {
            this._trigger("empty", []);
          }
          done = false;
          index = this._nextIndex++;
          this._running[index] = {
            timeout: setTimeout(() => {
              var completed;
              completed = (...args) => {
                var ref;
                if (!done) {
                  done = true;
                  delete this._running[index];
                  this._nbRunning--;
                  this._tryToRun();
                  if (this.nbRunning() === 0 && this.nbQueued() === 0) {
                    this._trigger("idle", []);
                  }
                  if (!this.interrupt) {
                    return (ref = next.cb) != null ? ref.apply({}, args) : void 0;
                  }
                }
              };
              if (this.limiter != null) {
                return this.limiter.submit.apply(this.limiter, Array.prototype.concat(next.task, next.args, completed));
              } else {
                return next.task.apply({}, next.args.concat(completed));
              }
            }, wait),
            job: next
          };
          return true;
        } else {
          return false;
        }
      }

      submit(...args) {
        return this.submitPriority.apply({}, Array.prototype.concat(MIDDLE_PRIORITY, args));
      }

      submitPriority(priority, task, ...args) {
        var cb, j, job, reachedHighWaterMark, ref, shifted;
        ref = args, args = 2 <= ref.length ? slice.call(ref, 0, j = ref.length - 1) : (j = 0, []), cb = ref[j++];
        job = {task, args, cb};
        priority = this._sanitizePriority(priority);
        reachedHighWaterMark = this.highWater >= 0 && this.nbQueued() === this.highWater && !this.check();
        if (this.strategy === Bottleneck.prototype.strategy.BLOCK && (reachedHighWaterMark || this.isBlocked())) {
          this._unblockTime = Date.now() + this.penalty;
          this._nextRequest = this._unblockTime + this.minTime;
          this._queues = this._makeQueues();
          this._trigger("dropped", [job]);
          return true;
        } else if (reachedHighWaterMark) {
          shifted = this.strategy === Bottleneck.prototype.strategy.LEAK ? (this._getFirst(this._queues.slice(priority).reverse())).shift() : this.strategy === Bottleneck.prototype.strategy.OVERFLOW_PRIORITY ? (this._getFirst(this._queues.slice(priority + 1).reverse())).shift() : this.strategy === Bottleneck.prototype.strategy.OVERFLOW ? job : void 0;
          if (shifted != null) {
            this._trigger("dropped", [shifted]);
          }
          if ((shifted == null) || this.strategy === Bottleneck.prototype.strategy.OVERFLOW) {
            return reachedHighWaterMark;
          }
        }
        this._queues[priority].push(job);
        this._tryToRun();
        return reachedHighWaterMark;
      }

      schedule(...args) {
        return this.schedulePriority.apply({}, Array.prototype.concat(MIDDLE_PRIORITY, args));
      }

      schedulePriority(priority, task, ...args) {
        var wrapped;
        wrapped = function(...args) {
          var cb, j, ref;
          ref = args, args = 2 <= ref.length ? slice.call(ref, 0, j = ref.length - 1) : (j = 0, []), cb = ref[j++];
          return (task.apply({}, args)).then(function(...args) {
            return cb.apply({}, Array.prototype.concat(null, args));
          }).catch(function(...args) {
            return cb.apply({}, args);
          });
        };
        return new Bottleneck.prototype.Promise((resolve, reject) => {
          return this.submitPriority.apply({}, Array.prototype.concat(priority, wrapped, args, function(...args) {
            return (args[0] != null ? reject : (args.shift(), resolve)).apply({}, args);
          }));
        });
      }

      changeSettings(maxNb = this.maxNb, minTime = this.minTime, highWater = this.highWater, strategy = this.strategy, rejectOnDrop = this.rejectOnDrop) {
        this.maxNb = maxNb;
        this.minTime = minTime;
        this.highWater = highWater;
        this.strategy = strategy;
        this.rejectOnDrop = rejectOnDrop;
        while (this._tryToRun()) {}
        return this;
      }

      changePenalty(penalty = this.penalty) {
        this.penalty = penalty;
        return this;
      }

      changeReservoir(reservoir) {
        this.reservoir = reservoir;
        while (this._tryToRun()) {}
        return this;
      }

      incrementReservoir(incr = 0) {
        this.changeReservoir(this.reservoir + incr);
        return this;
      }

      on(name, cb) {
        if (this.events[name] != null) {
          this.events[name].push(cb);
        } else {
          this.events[name] = [cb];
        }
        return this;
      }

      removeAllListeners(name = null) {
        if (name != null) {
          delete this.events[name];
        } else {
          this.events = {};
        }
        return this;
      }

      stopAll(interrupt = this.interrupt) {
        var job, k, keys;
        this.interrupt = interrupt;
        keys = Object.keys(this._running);
        (function() {
          var j, len, results;
          results = [];
          for (j = 0, len = keys.length; j < len; j++) {
            k = keys[j];
            results.push(clearTimeout(this._running[k].timeout));
          }
          return results;
        }).call(this);
        this._tryToRun = function() {};
        this.check = function() {
          return false;
        };
        this.submit = this.submitPriority = function(...args) {
          var cb, j, ref;
          ref = args, args = 2 <= ref.length ? slice.call(ref, 0, j = ref.length - 1) : (j = 0, []), cb = ref[j++];
          return cb(new Bottleneck.prototype.BottleneckError("This limiter is stopped"));
        };
        this.schedule = this.schedulePriority = function() {
          return Promise.reject(new Bottleneck.prototype.BottleneckError("This limiter is stopped"));
        };
        if (this.interrupt) {
          (function() {
            var j, len, results;
            results = [];
            for (j = 0, len = keys.length; j < len; j++) {
              k = keys[j];
              results.push(this._trigger("dropped", [this._running[k].job]));
            }
            return results;
          }).call(this);
        }
        while (job = (this._getFirst(this._queues)).shift()) {
          this._trigger("dropped", [job]);
        }
        this._trigger("empty", []);
        if (this.nbRunning() === 0) {
          this._trigger("idle", []);
        }
        return this;
      }

    };

    Bottleneck.default = Bottleneck;

    Bottleneck.strategy = Bottleneck.prototype.strategy = {
      LEAK: 1,
      OVERFLOW: 2,
      OVERFLOW_PRIORITY: 4,
      BLOCK: 3
    };

    Bottleneck.BottleneckError = Bottleneck.prototype.BottleneckError = require("./BottleneckError");

    Bottleneck.Cluster = Bottleneck.prototype.Cluster = require("./Cluster");

    Bottleneck.DLList = Bottleneck.prototype.DLList = require("./DLList");

    Bottleneck.Promise = Bottleneck.prototype.Promise = (function() {
      try {
        return require("bluebird");
      } catch (error) {
        e = error;
        return typeof Promise !== "undefined" && Promise !== null ? Promise : function() {
          throw new Bottleneck.prototype.BottleneckError("Bottleneck: install 'bluebird' or use Node 0.12 or higher for Promise support");
        };
      }
    })();

    return Bottleneck;

  })();

  module.exports = Bottleneck;

}).call(this);

},{"./BottleneckError":2,"./Cluster":3,"./DLList":4,"bluebird":undefined}],2:[function(require,module,exports){
// Generated by CoffeeScript 2.0.2
(function() {
  var BottleneckError;

  BottleneckError = class BottleneckError extends Error {};

  module.exports = BottleneckError;

}).call(this);

},{}],3:[function(require,module,exports){
// Generated by CoffeeScript 2.0.2
(function() {
  var Cluster,
    hasProp = {}.hasOwnProperty;

  Cluster = class Cluster {
    constructor(maxNb, minTime, highWater, strategy, rejectOnDrop) {
      this.maxNb = maxNb;
      this.minTime = minTime;
      this.highWater = highWater;
      this.strategy = strategy;
      this.rejectOnDrop = rejectOnDrop;
      this.limiters = {};
      this.Bottleneck = require("./Bottleneck");
      this.timeout = 1000 * 60 * 5;
      this.startAutoCleanup();
    }

    key(key = "") {
      var ref;
      return (ref = this.limiters[key]) != null ? ref : (this.limiters[key] = new this.Bottleneck(this.maxNb, this.minTime, this.highWater, this.strategy, this.rejectOnDrop));
    }

    deleteKey(key = "") {
      return delete this.limiters[key];
    }

    all(cb) {
      var k, ref, results, v;
      ref = this.limiters;
      results = [];
      for (k in ref) {
        if (!hasProp.call(ref, k)) continue;
        v = ref[k];
        results.push(cb(v));
      }
      return results;
    }

    keys() {
      return Object.keys(this.limiters);
    }

    startAutoCleanup() {
      var base;
      this.stopAutoCleanup();
      return typeof (base = (this.interval = setInterval(() => {
        var k, ref, results, time, v;
        time = Date.now();
        ref = this.limiters;
        results = [];
        for (k in ref) {
          v = ref[k];
          if ((v._nextRequest + this.timeout) < time) {
            results.push(this.deleteKey(k));
          } else {
            results.push(void 0);
          }
        }
        return results;
      }, this.timeout / 10))).unref === "function" ? base.unref() : void 0;
    }

    stopAutoCleanup() {
      return clearInterval(this.interval);
    }

    changeTimeout(timeout) {
      this.timeout = timeout;
      return this.startAutoCleanup();
    }

  };

  module.exports = Cluster;

}).call(this);

},{"./Bottleneck":1}],4:[function(require,module,exports){
// Generated by CoffeeScript 2.0.2
(function() {
  var DLList;

  DLList = class DLList {
    constructor() {
      this._first = null;
      this._last = null;
      this.length = 0;
    }

    push(value) {
      var node;
      this.length++;
      node = {
        value,
        next: null
      };
      if (this._last != null) {
        this._last.next = node;
        this._last = node;
      } else {
        this._first = this._last = node;
      }
      return void 0;
    }

    shift() {
      var ref1, value;
      if (this._first == null) {
        return void 0;
      } else {
        this.length--;
      }
      value = this._first.value;
      this._first = (ref1 = this._first.next) != null ? ref1 : (this._last = null);
      return value;
    }

    getArray() {
      var node, ref, results;
      node = this._first;
      results = [];
      while (node != null) {
        results.push((ref = node, node = node.next, ref.value));
      }
      return results;
    }

  };

  module.exports = DLList;

}).call(this);

},{}],5:[function(require,module,exports){
(function (global){
// Generated by CoffeeScript 2.0.2
(function() {
  module.exports = require("./Bottleneck");

  if (global.window != null) {
    global.window.Bottleneck = module.exports;
  }

}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./Bottleneck":1}]},{},[5]);
