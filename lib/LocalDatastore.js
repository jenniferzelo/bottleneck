"use strict";

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

// Generated by CoffeeScript 2.3.1
(function () {
  var BottleneckError, DLList, LocalDatastore, parser;

  parser = require("./parser");

  DLList = require("./DLList");

  BottleneckError = require("./BottleneckError");

  LocalDatastore = class LocalDatastore {
    constructor(instance, options) {
      this.instance = instance;
      parser.load(options, options, this);
      this._nextRequest = Date.now();
      this._running = 0;
      this._executing = {};
      this._unblockTime = 0;
      this.ready = this.yieldLoop();
      this.clients = {};
    }

    __publish__(message) {
      var _this = this;

      return _asyncToGenerator(function* () {
        yield _this.yieldLoop();
        return _this.instance.Events.trigger("message", [message.toString()]);
      })();
    }

    __disconnect__(flush) {
      return this.Promise.resolve();
    }

    yieldLoop(t = 0) {
      return new this.Promise(function (resolve, reject) {
        return setTimeout(resolve, t);
      });
    }

    computePenalty() {
      var ref;
      return (ref = this.penalty) != null ? ref : 15 * this.minTime || 5000;
    }

    __updateSettings__(options) {
      var _this2 = this;

      return _asyncToGenerator(function* () {
        yield _this2.yieldLoop();
        parser.overwrite(options, options, _this2);
        return true;
      })();
    }

    __running__() {
      var _this3 = this;

      return _asyncToGenerator(function* () {
        yield _this3.yieldLoop();
        return _this3._running;
      })();
    }

    __groupCheck__(time) {
      var _this4 = this;

      return _asyncToGenerator(function* () {
        yield _this4.yieldLoop();
        return _this4._nextRequest + _this4.timeout < time;
      })();
    }

    conditionsCheck(weight) {
      return (this.maxConcurrent == null || this._running + weight <= this.maxConcurrent) && (this.reservoir == null || this.reservoir - weight >= 0);
    }

    __incrementReservoir__(incr) {
      var _this5 = this;

      return _asyncToGenerator(function* () {
        yield _this5.yieldLoop();
        return _this5.reservoir += incr;
      })();
    }

    __currentReservoir__() {
      var _this6 = this;

      return _asyncToGenerator(function* () {
        yield _this6.yieldLoop();
        return _this6.reservoir;
      })();
    }

    isBlocked(now) {
      return this._unblockTime >= now;
    }

    check(weight, now) {
      return this.conditionsCheck(weight) && this._nextRequest - now <= 0;
    }

    __check__(weight) {
      var _this7 = this;

      return _asyncToGenerator(function* () {
        var now;
        yield _this7.yieldLoop();
        now = Date.now();
        return _this7.check(weight, now);
      })();
    }

    __register__(index, weight, expiration) {
      var _this8 = this;

      return _asyncToGenerator(function* () {
        var now, wait;
        yield _this8.yieldLoop();
        now = Date.now();
        if (_this8.conditionsCheck(weight)) {
          _this8._running += weight;
          _this8._executing[index] = {
            timeout: expiration != null ? setTimeout(function () {
              if (!_this8._executing[index].freed) {
                _this8._executing[index].freed = true;
                return _this8._running -= weight;
              }
            }, expiration) : void 0,
            freed: false
          };
          if (_this8.reservoir != null) {
            _this8.reservoir -= weight;
          }
          wait = Math.max(_this8._nextRequest - now, 0);
          _this8._nextRequest = now + wait + _this8.minTime;
          return {
            success: true,
            wait,
            reservoir: _this8.reservoir
          };
        } else {
          return {
            success: false
          };
        }
      })();
    }

    strategyIsBlock() {
      return this.strategy === 3;
    }

    __submit__(queueLength, weight) {
      var _this9 = this;

      return _asyncToGenerator(function* () {
        var blocked, now, reachedHWM;
        yield _this9.yieldLoop();
        if (_this9.maxConcurrent != null && weight > _this9.maxConcurrent) {
          throw new BottleneckError(`Impossible to add a job having a weight of ${weight} to a limiter having a maxConcurrent setting of ${_this9.maxConcurrent}`);
        }
        now = Date.now();
        reachedHWM = _this9.highWater != null && queueLength === _this9.highWater && !_this9.check(weight, now);
        blocked = _this9.strategyIsBlock() && (reachedHWM || _this9.isBlocked(now));
        if (blocked) {
          _this9._unblockTime = now + _this9.computePenalty();
          _this9._nextRequest = _this9._unblockTime + _this9.minTime;
        }
        return {
          reachedHWM,
          blocked,
          strategy: _this9.strategy
        };
      })();
    }

    __free__(index, weight) {
      var _this10 = this;

      return _asyncToGenerator(function* () {
        yield _this10.yieldLoop();
        clearTimeout(_this10._executing[index].timeout);
        if (!_this10._executing[index].freed) {
          _this10._executing[index].freed = true;
          _this10._running -= weight;
        }
        return {
          running: _this10._running
        };
      })();
    }

  };

  module.exports = LocalDatastore;
}).call(undefined);