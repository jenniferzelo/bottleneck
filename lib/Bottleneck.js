"use strict";

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

// Generated by CoffeeScript 2.0.2
(function () {
  var Bottleneck,
      DEFAULT_PRIORITY,
      DLList,
      Local,
      NUM_PRIORITIES,
      RedisStorage,
      Sync,
      packagejson,
      parser,
      slice = [].slice;

  NUM_PRIORITIES = 10;

  DEFAULT_PRIORITY = 5;

  parser = require("./parser");

  Local = require("./Local");

  RedisStorage = require("./RedisStorage");

  DLList = require("./DLList");

  Sync = require("./Sync");

  packagejson = require("../package.json");

  Bottleneck = function () {
    class Bottleneck {
      constructor(options = {}, ...invalid) {
        var sDefaults;
        this.ready = this.ready.bind(this);
        this.clients = this.clients.bind(this);
        this.disconnect = this.disconnect.bind(this);
        this.chain = this.chain.bind(this);
        this.queued = this.queued.bind(this);
        this.running = this.running.bind(this);
        this.check = this.check.bind(this);
        this._drainOne = this._drainOne.bind(this);
        this.submit = this.submit.bind(this);
        this.schedule = this.schedule.bind(this);
        this.wrap = this.wrap.bind(this);
        this.updateSettings = this.updateSettings.bind(this);
        this.currentReservoir = this.currentReservoir.bind(this);
        this.incrementReservoir = this.incrementReservoir.bind(this);
        this.on = this.on.bind(this);
        this.once = this.once.bind(this);
        this.removeAllListeners = this.removeAllListeners.bind(this);
        if (!(options != null && typeof options === "object" && invalid.length === 0)) {
          throw new Bottleneck.prototype.BottleneckError("Bottleneck v2 takes a single object argument. Refer to https://github.com/SGrondin/bottleneck#upgrading-to-v2 if you're upgrading from Bottleneck v1.");
        }
        parser.load(options, this.instanceDefaults, this);
        this._queues = this._makeQueues();
        this._executing = {};
        this._limiter = null;
        this._events = {};
        this._submitLock = new Sync("submit");
        this._registerLock = new Sync("register");
        sDefaults = parser.load(options, this.storeDefaults, {});
        this._store = function () {
          if (this.datastore === "local") {
            return new Local(parser.load(options, this.storeInstanceDefaults, sDefaults));
          } else if (this.datastore === "redis") {
            return new RedisStorage(this, sDefaults, parser.load(options, this.storeInstanceDefaults, {}));
          } else {
            throw new Bottleneck.prototype.BottleneckError(`Invalid datastore type: ${this.datastore}`);
          }
        }.call(this);
      }

      ready() {
        return this._store.ready;
      }

      clients() {
        return this._store.clients;
      }

      disconnect(flush = true) {
        var _this = this;

        return _asyncToGenerator(function* () {
          return yield _this._store.disconnect(flush);
        })();
      }

      _addListener(name, status, cb) {
        var base;
        if ((base = this._events)[name] == null) {
          base[name] = [];
        }
        this._events[name].push({ cb, status });
        return this;
      }

      _trigger(name, args) {
        if (name !== "debug") {
          this._trigger("debug", [`Event triggered: ${name}`, args]);
        }
        if (name === "dropped" && this.rejectOnDrop) {
          args.forEach(function (job) {
            return job.cb.apply({}, [new Bottleneck.prototype.BottleneckError("This job has been dropped by Bottleneck")]);
          });
        }
        if (this._events[name] == null) {
          return;
        }
        this._events[name] = this._events[name].filter(function (listener) {
          return listener.status !== "none";
        });
        return this._events[name].forEach(listener => {
          var e, ret;
          if (listener.status === "none") {
            return;
          }
          if (listener.status === "once") {
            listener.status = "none";
          }
          try {
            ret = listener.cb.apply({}, args);
            if (typeof (ret != null ? ret.then : void 0) === "function") {
              return ret.then(function () {}).catch(e => {
                return this._trigger("error", [e]);
              });
            }
          } catch (error) {
            e = error;
            if ("name" !== "error") {
              return this._trigger("error", [e]);
            }
          }
        });
      }

      _makeQueues() {
        var i, j, ref, results;
        results = [];
        for (i = j = 1, ref = NUM_PRIORITIES; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
          results.push(new DLList());
        }
        return results;
      }

      chain(_limiter) {
        this._limiter = _limiter;
        return this;
      }

      _sanitizePriority(priority) {
        var sProperty;
        sProperty = ~~priority !== priority ? DEFAULT_PRIORITY : priority;
        if (sProperty < 0) {
          return 0;
        } else if (sProperty > NUM_PRIORITIES - 1) {
          return NUM_PRIORITIES - 1;
        } else {
          return sProperty;
        }
      }

      _find(arr, fn) {
        var ref;
        return (ref = function () {
          var i, j, len, x;
          for (i = j = 0, len = arr.length; j < len; i = ++j) {
            x = arr[i];
            if (fn(x)) {
              return x;
            }
          }
        }()) != null ? ref : [];
      }

      queued(priority) {
        if (priority != null) {
          return this._queues[priority].length;
        } else {
          return this._queues.reduce(function (a, b) {
            return a + b.length;
          }, 0);
        }
      }

      empty() {
        return this.queued() === 0 && this._submitLock.isEmpty();
      }

      running() {
        var _this2 = this;

        return _asyncToGenerator(function* () {
          return yield _this2._store.__running__();
        })();
      }

      _getFirst(arr) {
        return this._find(arr, function (x) {
          return x.length > 0;
        });
      }

      _randomIndex() {
        return Math.random().toString(36).slice(2);
      }

      check(weight = 1) {
        var _this3 = this;

        return _asyncToGenerator(function* () {
          return yield _this3._store.__check__(weight);
        })();
      }

      _run(next, wait, index) {
        var _this4 = this;

        var completed, done;
        this._trigger("debug", [`Scheduling ${next.options.id}`, {
          args: next.args,
          options: next.options
        }]);
        done = false;
        completed = (() => {
          var _ref = _asyncToGenerator(function* (...args) {
            var e, ref, running;
            if (!done) {
              try {
                done = true;
                clearTimeout(_this4._executing[index].expiration);
                delete _this4._executing[index];
                _this4._trigger("debug", [`Completed ${next.options.id}`, {
                  args: next.args,
                  options: next.options
                }]);

                var _ref2 = yield _this4._store.__free__(index, next.options.weight);

                running = _ref2.running;

                _this4._trigger("debug", [`Freed ${next.options.id}`, {
                  args: next.args,
                  options: next.options
                }]);
                _this4._drainAll().catch(function (e) {
                  return _this4._trigger("error", [e]);
                });
                if (running === 0 && _this4.empty()) {
                  _this4._trigger("idle", []);
                }
                return (ref = next.cb) != null ? ref.apply({}, args) : void 0;
              } catch (error) {
                e = error;
                return _this4._trigger("error", [e]);
              }
            }
          });

          return function completed() {
            return _ref.apply(this, arguments);
          };
        })();
        return this._executing[index] = {
          timeout: setTimeout(() => {
            this._trigger("debug", [`Executing ${next.options.id}`, {
              args: next.args,
              options: next.options
            }]);
            if (this._limiter != null) {
              return this._limiter.submit.apply(this._limiter, Array.prototype.concat(next.options, next.task, next.args, completed));
            } else {
              return next.task.apply({}, next.args.concat(completed));
            }
          }, wait),
          expiration: next.options.expiration != null ? setTimeout(() => {
            return completed(new Bottleneck.prototype.BottleneckError(`This job timed out after ${next.options.expiration} ms.`));
          }, next.options.expiration) : void 0,
          job: next
        };
      }

      _drainOne(freed) {
        return this._registerLock.schedule(() => {
          var args, index, options, queue;
          if (this.queued() === 0) {
            return this.Promise.resolve(false);
          }
          queue = this._getFirst(this._queues);

          var _queue$first = queue.first();

          options = _queue$first.options;
          args = _queue$first.args;

          if (freed != null && options.weight > freed) {
            return this.Promise.resolve(false);
          }
          this._trigger("debug", [`Draining ${options.id}`, { args, options }]);
          index = this._randomIndex();
          return this._store.__register__(index, options.weight, options.expiration).then(({ success, wait, reservoir }) => {
            var empty, next;
            this._trigger("debug", [`Drained ${options.id}`, { success, args, options }]);
            if (success) {
              next = queue.shift();
              empty = this.empty();
              if (empty) {
                this._trigger("empty", []);
              }
              if (reservoir === 0) {
                this._trigger("depleted", [empty]);
              }
              this._run(next, wait, index);
            }
            return this.Promise.resolve(success);
          });
        });
      }

      _drainAll(freed) {
        return this._drainOne(freed).then(success => {
          if (success) {
            return this._drainAll();
          } else {
            return this.Promise.resolve(success);
          }
        }).catch(e => {
          return this._trigger("error", [e]);
        });
      }

      submit(...args) {
        var _this5 = this;

        var cb, j, job, k, options, ref, ref1, task;
        if (typeof args[0] === "function") {
          ref = args, task = ref[0], args = 3 <= ref.length ? slice.call(ref, 1, j = ref.length - 1) : (j = 1, []), cb = ref[j++];
          options = this.jobDefaults;
        } else {
          ref1 = args, options = ref1[0], task = ref1[1], args = 4 <= ref1.length ? slice.call(ref1, 2, k = ref1.length - 1) : (k = 2, []), cb = ref1[k++];
          options = parser.load(options, this.jobDefaults);
        }
        job = { options, task, args, cb };
        options.priority = this._sanitizePriority(options.priority);
        this._trigger("debug", [`Queueing ${options.id}`, { args, options }]);
        return this._submitLock.schedule(_asyncToGenerator(function* () {
          var blocked, e, reachedHWM, shifted, strategy;
          try {
            var _ref4 = yield _this5._store.__submit__(_this5.queued(), options.weight);

            reachedHWM = _ref4.reachedHWM;
            blocked = _ref4.blocked;
            strategy = _ref4.strategy;

            _this5._trigger("debug", [`Queued ${options.id}`, { args, options, reachedHWM, blocked }]);
          } catch (error) {
            e = error;
            _this5._trigger("debug", [`Could not queue ${options.id}`, {
              args,
              options,
              error: e
            }]);
            job.cb(e);
            return false;
          }
          if (blocked) {
            _this5._queues = _this5._makeQueues();
            _this5._trigger("dropped", [job]);
            return true;
          } else if (reachedHWM) {
            shifted = strategy === Bottleneck.prototype.strategy.LEAK ? _this5._getFirst(_this5._queues.slice(options.priority).reverse()).shift() : strategy === Bottleneck.prototype.strategy.OVERFLOW_PRIORITY ? _this5._getFirst(_this5._queues.slice(options.priority + 1).reverse()).shift() : strategy === Bottleneck.prototype.strategy.OVERFLOW ? job : void 0;
            if (shifted != null) {
              _this5._trigger("dropped", [shifted]);
            }
            if (shifted == null || strategy === Bottleneck.prototype.strategy.OVERFLOW) {
              return reachedHWM;
            }
          }
          _this5._queues[options.priority].push(job);
          yield _this5._drainAll();
          return reachedHWM;
        }));
      }

      schedule(...args) {
        var options, task, wrapped;
        if (typeof args[0] === "function") {
          var _args = args;

          var _args2 = _toArray(_args);

          task = _args2[0];
          args = _args2.slice(1);

          options = this.jobDefaults;
        } else {
          var _args3 = args;

          var _args4 = _toArray(_args3);

          options = _args4[0];
          task = _args4[1];
          args = _args4.slice(2);

          options = parser.load(options, this.jobDefaults);
        }
        wrapped = function wrapped(...args) {
          var cb, j, ref;
          ref = args, args = 2 <= ref.length ? slice.call(ref, 0, j = ref.length - 1) : (j = 0, []), cb = ref[j++];
          return task.apply({}, args).then(function (...args) {
            return cb.apply({}, Array.prototype.concat(null, args));
          }).catch(function (...args) {
            return cb.apply({}, args);
          });
        };
        return new this.Promise((resolve, reject) => {
          return this.submit.apply({}, Array.prototype.concat(options, wrapped, args, function (...args) {
            return (args[0] != null ? reject : (args.shift(), resolve)).apply({}, args);
          })).catch(e => {
            return this._trigger("error", [e]);
          });
        });
      }

      wrap(fn) {
        return (...args) => {
          return this.schedule.apply({}, Array.prototype.concat(fn, args));
        };
      }

      updateSettings(options = {}) {
        var _this6 = this;

        return _asyncToGenerator(function* () {
          yield _this6._store.__updateSettings__(parser.overwrite(options, _this6.storeDefaults));
          parser.overwrite(options, _this6.instanceDefaults, _this6);
          _this6._drainAll().catch(function (e) {
            return _this6._trigger("error", [e]);
          });
          return _this6;
        })();
      }

      currentReservoir() {
        var _this7 = this;

        return _asyncToGenerator(function* () {
          return yield _this7._store.__currentReservoir__();
        })();
      }

      incrementReservoir(incr = 0) {
        var _this8 = this;

        return _asyncToGenerator(function* () {
          yield _this8._store.__incrementReservoir__(incr);
          _this8._drainAll().catch(function (e) {
            return _this8._trigger("error", [e]);
          });
          return _this8;
        })();
      }

      on(name, cb) {
        return this._addListener(name, "many", cb);
      }

      once(name, cb) {
        return this._addListener(name, "once", cb);
      }

      removeAllListeners(name = null) {
        if (name != null) {
          delete this._events[name];
        } else {
          this._events = {};
        }
        return this;
      }

    };

    Bottleneck.default = Bottleneck;

    Bottleneck.version = Bottleneck.prototype.version = packagejson.version;

    Bottleneck.strategy = Bottleneck.prototype.strategy = {
      LEAK: 1,
      OVERFLOW: 2,
      OVERFLOW_PRIORITY: 4,
      BLOCK: 3
    };

    Bottleneck.BottleneckError = Bottleneck.prototype.BottleneckError = require("./BottleneckError");

    Bottleneck.Group = Bottleneck.prototype.Group = require("./Group");

    Bottleneck.prototype.jobDefaults = {
      priority: DEFAULT_PRIORITY,
      weight: 1,
      expiration: null,
      id: "<no-id>"
    };

    Bottleneck.prototype.storeDefaults = {
      maxConcurrent: null,
      minTime: 0,
      highWater: null,
      strategy: Bottleneck.prototype.strategy.LEAK,
      penalty: null,
      reservoir: null
    };

    Bottleneck.prototype.storeInstanceDefaults = {
      clientOptions: {},
      clearDatastore: false,
      Promise: Promise
    };

    Bottleneck.prototype.instanceDefaults = {
      datastore: "local",
      id: "<no-id>",
      rejectOnDrop: true,
      Promise: Promise
    };

    return Bottleneck;
  }();

  module.exports = Bottleneck;
}).call(undefined);