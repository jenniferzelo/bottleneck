// Generated by CoffeeScript 2.0.2
(function() {
  var BottleneckError, DLList, RedisStorage, e, fs, libraries, parser, redis, scripts;

  parser = require("./parser");

  DLList = require("./DLList");

  BottleneckError = require("./BottleneckError");

  redis = (function() {
    try {
      return require("redis");
    } catch (error) {
      e = error;
      return null;
    }
  })();

  fs = require("fs");

  libraries = {};

  scripts = {
    init: {
      keys: ["b_settings", "b_running", "b_executing"],
      libs: []
    },
    updateSettings: {
      keys: ["b_settings"],
      libs: []
    },
    running: {
      keys: ["b_settings", "b_running", "b_executing"],
      libs: ["refresh_running"]
    },
    check: {
      keys: ["b_settings", "b_running", "b_executing"],
      libs: ["refresh_running", "conditions_check"]
    },
    submit: {
      keys: ["b_settings", "b_running", "b_executing"],
      libs: ["refresh_running", "conditions_check"]
    },
    register: {
      keys: ["b_settings", "b_running", "b_executing"],
      libs: ["refresh_running", "conditions_check"]
    },
    free: {
      keys: ["b_settings", "b_running", "b_executing"],
      libs: ["refresh_running"]
    },
    current_reservoir: {
      keys: ["b_settings"],
      libs: []
    },
    increment_reservoir: {
      keys: ["b_settings"],
      libs: []
    }
  };

  // Runs as-is in Node, but it also gets preprocessed by brfs
  // brfs looks for the pattern "fs.readFile [string], [function]", can't use variables here
  fs.readFile("./src/redis/refresh_running.lua", function(err, data) {
    if (err != null) {
      throw err;
    } else {
      return libraries["refresh_running"] = data.toString("utf8");
    }
  });

  fs.readFile("./src/redis/conditions_check.lua", function(err, data) {
    if (err != null) {
      throw err;
    } else {
      return libraries["conditions_check"] = data.toString("utf8");
    }
  });

  fs.readFile("./src/redis/init.lua", function(err, data) {
    if (err != null) {
      throw err;
    } else {
      return scripts["init"].code = data.toString("utf8");
    }
  });

  fs.readFile("./src/redis/running.lua", function(err, data) {
    if (err != null) {
      throw err;
    } else {
      return scripts["running"].code = data.toString("utf8");
    }
  });

  fs.readFile("./src/redis/update_settings.lua", function(err, data) {
    if (err != null) {
      throw err;
    } else {
      return scripts["updateSettings"].code = data.toString("utf8");
    }
  });

  fs.readFile("./src/redis/check.lua", function(err, data) {
    if (err != null) {
      throw err;
    } else {
      return scripts["check"].code = data.toString("utf8");
    }
  });

  fs.readFile("./src/redis/submit.lua", function(err, data) {
    if (err != null) {
      throw err;
    } else {
      return scripts["submit"].code = data.toString("utf8");
    }
  });

  fs.readFile("./src/redis/register.lua", function(err, data) {
    if (err != null) {
      throw err;
    } else {
      return scripts["register"].code = data.toString("utf8");
    }
  });

  fs.readFile("./src/redis/free.lua", function(err, data) {
    if (err != null) {
      throw err;
    } else {
      return scripts["free"].code = data.toString("utf8");
    }
  });

  fs.readFile("./src/redis/current_reservoir.lua", function(err, data) {
    if (err != null) {
      throw err;
    } else {
      return scripts["current_reservoir"].code = data.toString("utf8");
    }
  });

  fs.readFile("./src/redis/increment_reservoir.lua", function(err, data) {
    if (err != null) {
      throw err;
    } else {
      return scripts["increment_reservoir"].code = data.toString("utf8");
    }
  });

  RedisStorage = class RedisStorage {
    constructor(initSettings, options) {
      this.loadAll = this.loadAll.bind(this);
      if (redis == null) {
        require("redis"); // Triggers an error on purpose
      }
      parser.load(options, options, this);
      this.client = redis.createClient(this.clientOptions);
      this.shas = {};
      this.ready = new this.Promise((resolve, reject) => {
        this.client.on("error", function(e) {
          return reject(e);
        });
        return this.client.on("ready", () => {
          return resolve();
        });
      }).then(this.loadAll).then(() => {
        var args;
        initSettings.nextRequest = Date.now();
        initSettings.running = 0;
        initSettings.unblockTime = 0;
        // initSettings.version =
        args = this.prepareObject(initSettings);
        args.unshift((options.clearDatastore ? 1 : 0));
        return this.runScript("init", args);
      }).then((results) => {
        return console.log(this.shas);
      });
    }

    loadScript(name) {
      return new this.Promise((resolve, reject) => {
        var payload;
        payload = scripts[name].libs.map(function(lib) {
          return libraries[lib];
        }).join("\n") + scripts[name].code;
        return this.client.multi([["script", "load", payload]]).exec((err, replies) => {
          if (err != null) {
            return reject(err);
          }
          this.shas[name] = replies[0];
          return resolve(replies[0]);
        });
      });
    }

    loadAll() {
      var k, v;
      return this.Promise.all((function() {
        var results1;
        results1 = [];
        for (k in scripts) {
          v = scripts[k];
          results1.push(this.loadScript(k));
        }
        return results1;
      }).call(this));
    }

    prepareArray(arr) {
      return arr.map(function(x) {
        if (x != null) {
          return x.toString();
        } else {
          return "";
        }
      });
    }

    prepareObject(obj) {
      var arr, k, v;
      arr = [];
      for (k in obj) {
        v = obj[k];
        arr.push(k, (v != null ? v.toString() : ""));
      }
      return arr;
    }

    runScript(name, args) {
      return new this.Promise((resolve, reject) => {
        var arr, script;
        script = scripts[name];
        arr = [this.shas[name], script.keys.length].concat(script.keys, args, function(err, replies) {
          if (err != null) {
            reject(err);
          }
          return resolve(replies);
        });
        console.log(`Calling ${name}`, JSON.stringify(arr));
        return this.client.evalsha.bind(this.client).apply({}, arr);
      });
    }

    convertBool(b) {
      return !!b;
    }

    yieldLoop(t = 0) {
      return new this.Promise(function(resolve, reject) {
        return setTimeout(resolve, t);
      });
    }

    __updateSettings__(options) {
      return this.runScript("updateSettings", this.prepareObject(options));
    }

    __running__() {
      return this.runScript("running", [Date.now()]);
    }

    __incrementReservoir__(incr) {
      return this.runScript("increment_reservoir", [incr]);
    }

    __currentReservoir__() {
      return this.runScript("current_reservoir", this.prepareArray([false]));
    }

    async __check__(weight) {
      return this.convertBool((await this.runScript("check", this.prepareArray([weight, Date.now()]))));
    }

    async __register__(index, weight, expiration) {
      var success, wait;
      [success, wait] = (await this.runScript("register", this.prepareArray([index, weight, expiration, Date.now()])));
      return {
        // console.log "&&&&&&&", @convertBool(success), wait
        // throw new BottleneckError "WOOOOP"
        success: this.convertBool(success),
        wait
      };
    }

    async __submit__(queueLength, weight) {
      var blocked, maxConcurrent, overweight, reachedHWM, strategy;
      try {
        [reachedHWM, blocked, strategy] = (await this.runScript("submit", this.prepareArray([queueLength, weight, Date.now()])));
        return {
          // console.log(@convertBool(reachedHWM), @convertBool(blocked), strategy)

          // throw new BottleneckError "DERRP"
          reachedHWM: this.convertBool(reachedHWM),
          blocked: this.convertBool(blocked),
          strategy
        };
      } catch (error) {
        e = error;
        if (e.message.indexOf("OVERWEIGHT") === 0) {
          [overweight, weight, maxConcurrent] = e.message.split(" ");
          throw new BottleneckError(`Impossible to add a job having a weight of ${weight} to a limiter having a maxConcurrent setting of ${maxConcurrent}`);
        } else {
          throw e;
        }
      }
    }

    async __free__(index, weight) {
      var result;
      result = (await this.runScript("free", this.prepareArray([index, Date.now()])));
      return {
        // console.log('FREEEEE, RUNNING:', result)
        running: result
      };
    }

  };

  module.exports = RedisStorage;

}).call(this);
