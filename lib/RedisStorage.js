// Generated by CoffeeScript 2.0.2
(function() {
  var BottleneckError, DLList, RedisStorage, libraries, lua, parser, scripts;

  parser = require("./parser");

  DLList = require("./DLList");

  BottleneckError = require("./BottleneckError");

  lua = require("./lua.json");

  libraries = {
    get_time: lua["get_time.lua"],
    refresh_running: lua["refresh_running.lua"],
    conditions_check: lua["conditions_check.lua"]
  };

  scripts = {
    init: {
      keys: ["b_settings", "b_running", "b_executing"],
      libs: [],
      code: lua["init.lua"]
    },
    update_settings: {
      keys: ["b_settings"],
      libs: [],
      code: lua["update_settings.lua"]
    },
    running: {
      keys: ["b_settings", "b_running", "b_executing"],
      libs: ["refresh_running"],
      code: lua["running.lua"]
    },
    group_check: {
      keys: ["b_settings"],
      libs: [],
      code: lua["group_check.lua"]
    },
    check: {
      keys: ["b_settings", "b_running", "b_executing"],
      libs: ["refresh_running", "conditions_check"],
      code: lua["check.lua"]
    },
    submit: {
      keys: ["b_settings", "b_running", "b_executing"],
      libs: ["refresh_running", "conditions_check"],
      code: lua["submit.lua"]
    },
    register: {
      keys: ["b_settings", "b_running", "b_executing"],
      libs: ["refresh_running", "conditions_check"],
      code: lua["register.lua"]
    },
    free: {
      keys: ["b_settings", "b_running", "b_executing"],
      libs: ["refresh_running"],
      code: lua["free.lua"]
    },
    current_reservoir: {
      keys: ["b_settings"],
      libs: [],
      code: lua["current_reservoir.lua"]
    },
    increment_reservoir: {
      keys: ["b_settings"],
      libs: [],
      code: lua["increment_reservoir.lua"]
    }
  };

  RedisStorage = class RedisStorage {
    constructor(instance, initSettings, options) {
      var redis;
      this.loadAll = this.loadAll.bind(this);
      this.instance = instance;
      redis = require("redis");
      parser.load(options, options, this);
      this.client = redis.createClient(this.clientOptions);
      this.subClient = redis.createClient(this.clientOptions);
      this.shas = {};
      this.clients = {
        client: this.client,
        subscriber: this.subClient
      };
      this.ready = new this.Promise((resolve, reject) => {
        var count, done, errorListener;
        errorListener = function(e) {
          return reject(e);
        };
        count = 0;
        done = () => {
          count++;
          if (count === 2) {
            [this.client, this.subClient].forEach((client) => {
              client.removeListener("error", errorListener);
              return client.on("error", (e) => {
                return this.instance._trigger("error", [e]);
              });
            });
            return resolve();
          }
        };
        this.client.on("error", errorListener);
        this.client.on("ready", function() {
          return done();
        });
        this.subClient.on("error", errorListener);
        return this.subClient.on("ready", () => {
          this.subClient.on("subscribe", function() {
            return done();
          });
          return this.subClient.subscribe("bottleneck");
        });
      }).then(this.loadAll).then(() => {
        var args;
        this.subClient.on("message", (channel, message) => {
          var info, type;
          [type, info] = message.split(":");
          if (type === "freed") {
            return this.instance._drainAll(~~info);
          }
        });
        initSettings.nextRequest = Date.now();
        initSettings.running = 0;
        initSettings.unblockTime = 0;
        initSettings.version = this.instance.version;
        args = this.prepareObject(initSettings);
        args.unshift((options.clearDatastore ? 1 : 0));
        return this.runScript("init", args);
      }).then((results) => {
        return this.clients;
      });
    }

    disconnect(flush) {
      this.client.end(flush);
      this.subClient.end(flush);
      return this;
    }

    loadScript(name) {
      return new this.Promise((resolve, reject) => {
        var payload;
        payload = scripts[name].libs.map(function(lib) {
          return libraries[lib];
        }).join("\n") + scripts[name].code;
        return this.client.multi([["script", "load", payload]]).exec((err, replies) => {
          if (err != null) {
            return reject(err);
          }
          this.shas[name] = replies[0];
          return resolve(replies[0]);
        });
      });
    }

    loadAll() {
      var k, v;
      return this.Promise.all((function() {
        var results1;
        results1 = [];
        for (k in scripts) {
          v = scripts[k];
          results1.push(this.loadScript(k));
        }
        return results1;
      }).call(this));
    }

    prepareArray(arr) {
      return arr.map(function(x) {
        if (x != null) {
          return x.toString();
        } else {
          return "";
        }
      });
    }

    prepareObject(obj) {
      var arr, k, v;
      arr = [];
      for (k in obj) {
        v = obj[k];
        arr.push(k, (v != null ? v.toString() : ""));
      }
      return arr;
    }

    runScript(name, args) {
      return new this.Promise((resolve, reject) => {
        var arr, script;
        script = scripts[name];
        arr = [this.shas[name], script.keys.length].concat(script.keys, args, function(err, replies) {
          if (err != null) {
            return reject(err);
          }
          return resolve(replies);
        });
        return this.client.evalsha.bind(this.client).apply({}, arr);
      });
    }

    convertBool(b) {
      return !!b;
    }

    async __updateSettings__(options) {
      return (await this.runScript("update_settings", this.prepareObject(options)));
    }

    async __running__() {
      return (await this.runScript("running", [Date.now()]));
    }

    async __groupCheck__() {
      return parseInt((await this.runScript("group_check", [])), 10);
    }

    async __incrementReservoir__(incr) {
      return (await this.runScript("increment_reservoir", [incr]));
    }

    async __currentReservoir__() {
      return (await this.runScript("current_reservoir", []));
    }

    async __check__(weight) {
      return this.convertBool((await this.runScript("check", this.prepareArray([weight, Date.now()]))));
    }

    async __register__(index, weight, expiration) {
      var reservoir, success, wait;
      [success, wait, reservoir] = (await this.runScript("register", this.prepareArray([index, weight, expiration, Date.now()])));
      return {
        success: this.convertBool(success),
        wait,
        reservoir
      };
    }

    async __submit__(queueLength, weight) {
      var blocked, e, maxConcurrent, overweight, reachedHWM, strategy;
      try {
        [reachedHWM, blocked, strategy] = (await this.runScript("submit", this.prepareArray([queueLength, weight, Date.now()])));
        return {
          reachedHWM: this.convertBool(reachedHWM),
          blocked: this.convertBool(blocked),
          strategy
        };
      } catch (error) {
        e = error;
        if (e.message.indexOf("OVERWEIGHT") === 0) {
          [overweight, weight, maxConcurrent] = e.message.split(":");
          throw new BottleneckError(`Impossible to add a job having a weight of ${weight} to a limiter having a maxConcurrent setting of ${maxConcurrent}`);
        } else {
          throw e;
        }
      }
    }

    async __free__(index, weight) {
      var result;
      result = (await this.runScript("free", this.prepareArray([index, Date.now()])));
      return {
        running: result
      };
    }

  };

  module.exports = RedisStorage;

}).call(this);
