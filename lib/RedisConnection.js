"use strict";

// Generated by CoffeeScript 2.3.1
(function () {
  var Events, RedisConnection, Scripts, parser;

  parser = require("./parser");

  Events = require("./Events");

  Scripts = require("./Scripts");

  RedisConnection = function () {
    class RedisConnection {
      constructor(options) {
        var Redis;
        Redis = eval("require")("redis"); // Obfuscated or else Webpack/Angular will try to inline the optional redis module
        parser.load(options, this.defaults, this);
        if (this.Events == null) {
          this.Events = new Events(this);
        }
        this.client = Redis.createClient(this.clientOptions);
        this.subClient = Redis.createClient(this.clientOptions);
        this.pubsubs = {};
        this.shas = {};
        this.ready = new this.Promise((resolve, reject) => {
          var count, done, errorListener;
          errorListener = e => {
            return this.Events.trigger("error", [e]);
          };
          count = 0;
          done = () => {
            count++;
            if (count === 2) {
              [this.client, this.subClient].forEach(c => {
                return c.removeAllListeners("ready");
              });
              return resolve();
            }
          };
          this.client.on("error", errorListener);
          this.client.on("ready", function () {
            return done();
          });
          this.subClient.on("error", errorListener);
          this.subClient.on("ready", function () {
            return done();
          });
          return this.subClient.on("message", (channel, message) => {
            var base;
            return typeof (base = this.pubsubs)[channel] === "function" ? base[channel](message) : void 0;
          });
        }).then(() => {
          return this.Promise.all(Scripts.names.map(k => {
            return this._loadScript(k);
          }));
        }).then(() => {
          return this.Promise.resolve({
            client: this.client,
            subscriber: this.subClient
          });
        });
      }

      _loadScript(name) {
        return new this.Promise((resolve, reject) => {
          var payload;
          payload = Scripts.payload(name);
          return this.client.multi([["script", "load", payload]]).exec((err, replies) => {
            if (err != null) {
              return reject(err);
            }
            this.shas[name] = replies[0];
            return resolve(replies[0]);
          });
        });
      }

      addLimiter(instance, pubsub) {
        return new instance.Promise((resolve, reject) => {
          this.subClient.on("subscribe", () => {
            this.pubsubs[instance._channel()] = pubsub;
            return resolve();
          });
          return this.subClient.subscribe(instance._channel());
        });
      }

      removeLimiter(instance) {
        return delete this.pubsubs[instance._channel()];
      }

      scriptArgs(name, id, args, cb) {
        var keys;
        keys = Scripts.keys(name, id);
        return [this.shas[name], keys.length].concat(keys, args, cb);
      }

      scriptFn(name) {
        return this.client.evalsha.bind(this.client);
      }

      disconnect(flush) {
        this.client.end(flush);
        this.subClient.end(flush);
        return this.Promise.resolve();
      }

    };

    RedisConnection.prototype.defaults = {
      clientOptions: {},
      Promise: Promise,
      Events: null
    };

    return RedisConnection;
  }.call(this);

  module.exports = RedisConnection;
}).call(undefined);