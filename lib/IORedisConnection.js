"use strict";

// Generated by CoffeeScript 2.3.1
(function () {
  var IORedisConnection, Scripts;

  Scripts = require("./Scripts");

  IORedisConnection = class IORedisConnection {
    constructor(clusterNodes, clientOptions, Promise, Events) {
      var Redis;
      this.clusterNodes = clusterNodes;
      this.clientOptions = clientOptions;
      this.Promise = Promise;
      this.Events = Events;
      Redis = eval("require")("ioredis"); // Obfuscated or else Webpack/Angular will try to inline the optional ioredis module
      if (this.clusterNodes != null) {
        this.client = new Redis.Cluster(this.clusterNodes, this.clientOptions);
        this.subClient = new Redis.Cluster(this.clusterNodes, this.clientOptions);
      } else {
        this.client = new Redis(this.clientOptions);
        this.subClient = new Redis(this.clientOptions);
      }
      this.pubsubs = {};
      this.ready = new this.Promise((resolve, reject) => {
        var count, done, errorListener;
        errorListener = e => {
          return this.Events.trigger("error", [e]);
        };
        count = 0;
        done = () => {
          count++;
          if (count === 2) {
            [this.client, this.subClient].forEach(c => {
              return c.removeAllListeners("ready");
            });
            return resolve();
          }
        };
        this.client.on("error", errorListener);
        this.client.on("ready", function () {
          return done();
        });
        this.subClient.on("error", errorListener);
        this.subClient.on("ready", function () {
          return done();
        });
        return this.subClient.on("message", (channel, message) => {
          var base;
          return typeof (base = this.pubsubs)[channel] === "function" ? base[channel](message) : void 0;
        });
      }).then(() => {
        return Scripts.names.forEach(name => {
          return this.client.defineCommand(name, {
            lua: Scripts.payload(name)
          });
        });
      }).then(() => {
        return this.Promise.resolve({
          client: this.client,
          subscriber: this.subClient
        });
      });
    }

    addLimiter(instance, pubsub) {
      return new instance.Promise((resolve, reject) => {
        return this.subClient.subscribe(instance._channel(), () => {
          this.pubsubs[instance._channel()] = pubsub;
          return resolve();
        });
      });
    }

    removeLimiter(instance) {
      return delete this.pubsubs[instance._channel()];
    }

    scriptArgs(name, id, args, cb) {
      var keys;
      keys = Scripts.keys(name, id);
      return [keys.length].concat(keys, args, cb);
    }

    scriptFn(name) {
      return this.client[name].bind(this.client);
    }

    disconnect(flush) {
      if (flush) {
        return this.Promise.all([this.client.quit(), this.subClient.quit()]);
      } else {
        this.client.disconnect();
        this.subClient.disconnect();
        return this.Promise.resolve();
      }
    }

  };

  module.exports = IORedisConnection;
}).call(undefined);