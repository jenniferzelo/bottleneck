// Generated by CoffeeScript 2.0.2
(function() {
  var BottleneckError, DLList, Local, parser;

  parser = require("./parser");

  DLList = require("./DLList");

  BottleneckError = require("./BottleneckError");

  Local = class Local {
    constructor(options) {
      parser.load(options, options, this);
      this._nextRequest = Date.now();
      this._running = 0;
      this._unblockTime = 0;
    }

    computePenalty() {
      var ref;
      return (ref = this.penalty) != null ? ref : (15 * this.minTime) || 5000;
    }

    __updateSettings__(options) {
      parser.overwrite(options, options, this);
      return this;
    }

    __running__() {
      return this._running;
    }

    conditionsCheck(weight) {
      return ((this.maxConcurrent == null) || this._running + weight <= this.maxConcurrent) && ((this.reservoir == null) || this.reservoir - weight >= 0);
    }

    __incrementReservoir__(incr) {
      return this.reservoir += incr;
    }

    __currentReservoir__() {
      return this.reservoir;
    }

    isBlocked(now) {
      return this._unblockTime >= now;
    }

    check(weight, now) {
      return this.conditionsCheck(weight) && (this._nextRequest - now) <= 0;
    }

    __check__(weight) {
      return this.check(weight, Date.now());
    }

    __register__(weight) {
      var now, wait;
      now = Date.now();
      if (this.conditionsCheck(weight)) {
        this._running += weight;
        if (this.reservoir != null) {
          this.reservoir -= weight;
        }
        wait = Math.max(this._nextRequest - now, 0);
        this._nextRequest = now + wait + this.minTime;
        return {
          success: true,
          wait
        };
      } else {
        return {
          success: false
        };
      }
    }

    __submit__(queueLength, weight) {
      var blocked, now, reachedHighWaterMark;
      if ((this.maxConcurrent != null) && weight > this.maxConcurrent) {
        throw new BottleneckError(`Impossible to add a job having a weight of ${weight} to a limiter having a maxConcurrent setting of ${this.maxConcurrent}`);
      }
      now = Date.now();
      reachedHighWaterMark = (this.highWater != null) && queueLength === this.highWater && !this.check(weight, now);
      blocked = this.strategy === 3 && (reachedHighWaterMark || this.isBlocked(now));
      if (blocked) {
        this._unblockTime = now + this.computePenalty();
        this._nextRequest = this._unblockTime + this.minTime;
      }
      return {
        reachedHighWaterMark,
        blocked,
        strategy: this.strategy
      };
    }

    __free__(weight) {
      this._running -= weight;
      return {
        running: this._running
      };
    }

  };

  module.exports = Local;

}).call(this);
