// Generated by CoffeeScript 2.0.2
(function() {
  var BottleneckError, DLList, Local, parser;

  parser = require("./parser");

  DLList = require("./DLList");

  BottleneckError = require("./BottleneckError");

  Local = class Local {
    constructor(options) {
      parser.load(options, options, this);
      this._nextRequest = Date.now();
      this._running = 0;
      this._executing = {};
      this._unblockTime = 0;
      this.ready = this.yieldLoop();
      this.clients = {};
    }

    disconnect(flush) {
      return this;
    }

    yieldLoop(t = 0) {
      return new this.Promise(function(resolve, reject) {
        return setTimeout(resolve, t);
      });
    }

    computePenalty() {
      var ref;
      return (ref = this.penalty) != null ? ref : (15 * this.minTime) || 5000;
    }

    async __updateSettings__(options) {
      await this.yieldLoop();
      parser.overwrite(options, options, this);
      return true;
    }

    async __running__() {
      await this.yieldLoop();
      return this._running;
    }

    async __groupCheck__() {
      await this.yieldLoop();
      return this._nextRequest;
    }

    conditionsCheck(weight) {
      return ((this.maxConcurrent == null) || this._running + weight <= this.maxConcurrent) && ((this.reservoir == null) || this.reservoir - weight >= 0);
    }

    async __incrementReservoir__(incr) {
      await this.yieldLoop();
      return this.reservoir += incr;
    }

    async __currentReservoir__() {
      await this.yieldLoop();
      return this.reservoir;
    }

    isBlocked(now) {
      return this._unblockTime >= now;
    }

    check(weight, now) {
      return this.conditionsCheck(weight) && (this._nextRequest - now) <= 0;
    }

    async __check__(weight) {
      var now;
      await this.yieldLoop();
      now = Date.now();
      return this.check(weight, now);
    }

    async __register__(index, weight, expiration) {
      var now, wait;
      await this.yieldLoop();
      now = Date.now();
      if (this.conditionsCheck(weight)) {
        this._running += weight;
        this._executing[index] = {
          timeout: expiration != null ? setTimeout(() => {
            if (!this._executing[index].freed) {
              this._executing[index].freed = true;
              return this._running -= weight;
            }
          }, expiration) : void 0,
          freed: false
        };
        if (this.reservoir != null) {
          this.reservoir -= weight;
        }
        wait = Math.max(this._nextRequest - now, 0);
        this._nextRequest = now + wait + this.minTime;
        return {
          success: true,
          wait,
          reservoir: this.reservoir
        };
      } else {
        return {
          success: false
        };
      }
    }

    strategyIsBlock() {
      return this.strategy === 3;
    }

    async __submit__(queueLength, weight) {
      var blocked, now, reachedHWM;
      await this.yieldLoop();
      if ((this.maxConcurrent != null) && weight > this.maxConcurrent) {
        throw new BottleneckError(`Impossible to add a job having a weight of ${weight} to a limiter having a maxConcurrent setting of ${this.maxConcurrent}`);
      }
      now = Date.now();
      reachedHWM = (this.highWater != null) && queueLength === this.highWater && !this.check(weight, now);
      blocked = this.strategyIsBlock() && (reachedHWM || this.isBlocked(now));
      if (blocked) {
        this._unblockTime = now + this.computePenalty();
        this._nextRequest = this._unblockTime + this.minTime;
      }
      return {
        reachedHWM,
        blocked,
        strategy: this.strategy
      };
    }

    async __free__(index, weight) {
      await this.yieldLoop();
      clearTimeout(this._executing[index].timeout);
      if (!this._executing[index].freed) {
        this._executing[index].freed = true;
        this._running -= weight;
      }
      return {
        running: this._running
      };
    }

  };

  module.exports = Local;

}).call(this);
