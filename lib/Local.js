// Generated by CoffeeScript 2.0.2
(function() {
  var BottleneckError, DLList, Local, parser;

  parser = require("./parser");

  DLList = require("./DLList");

  BottleneckError = require("./BottleneckError");

  Local = class Local {
    constructor(options, instance) {
      this.instance = instance;
      parser.load(options, options, this);
      this._nextRequest = Date.now();
      this._running = 0;
      this._unblockTime = 0;
      this._ready = this.yieldLoop();
    }

    yieldLoop() {
      return new this.instance.Promise(function(resolve, reject) {
        return setTimeout(resolve, 0);
      });
    }

    computePenalty() {
      var ref;
      return (ref = this.penalty) != null ? ref : (15 * this.minTime) || 5000;
    }

    async __updateSettings__(options) {
      await this.yieldLoop();
      parser.overwrite(options, options, this);
      return true;
    }

    async __running__() {
      await this.yieldLoop();
      return this._running;
    }

    conditionsCheck(weight) {
      return ((this.maxConcurrent == null) || this._running + weight <= this.maxConcurrent) && ((this.reservoir == null) || this.reservoir - weight >= 0);
    }

    async __incrementReservoir__(incr) {
      await this.yieldLoop();
      return this.reservoir += incr;
    }

    async __currentReservoir__() {
      await this.yieldLoop();
      return this.reservoir;
    }

    isBlocked(now) {
      return this._unblockTime >= now;
    }

    check(weight, now) {
      return this.conditionsCheck(weight) && (this._nextRequest - now) <= 0;
    }

    async __check__(weight) {
      await this.yieldLoop();
      return this.check(weight, Date.now());
    }

    __register__(weight) {
      var now, wait;
      now = Date.now();
      if (this.conditionsCheck(weight)) {
        this._running += weight;
        if (this.reservoir != null) {
          this.reservoir -= weight;
        }
        wait = Math.max(this._nextRequest - now, 0);
        this._nextRequest = now + wait + this.minTime;
        return {
          success: true,
          wait
        };
      } else {
        return {
          success: false
        };
      }
    }

    __submit__(queueLength, weight) {
      var blocked, now, reachedHighWaterMark;
      if ((this.maxConcurrent != null) && weight > this.maxConcurrent) {
        throw new BottleneckError(`Impossible to add a job having a weight of ${weight} to a limiter having a maxConcurrent setting of ${this.maxConcurrent}`);
      }
      now = Date.now();
      reachedHighWaterMark = (this.highWater != null) && queueLength === this.highWater && !this.check(weight, now);
      blocked = this.strategy === this.instance.strategy.BLOCK && (reachedHighWaterMark || this.isBlocked(now));
      if (blocked) {
        this._unblockTime = now + this.computePenalty();
        this._nextRequest = this._unblockTime + this.minTime;
      }
      return {
        reachedHighWaterMark,
        blocked,
        strategy: this.strategy
      };
    }

    __free__(weight) {
      this._running -= weight;
      return {
        running: this._running
      };
    }

  };

  module.exports = Local;

}).call(this);
