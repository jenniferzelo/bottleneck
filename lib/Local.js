// Generated by CoffeeScript 2.0.2
(function() {
  var Bottleneck, DLList, Local, parser;

  parser = require("./parser");

  DLList = require("./DLList");

  Bottleneck = require("./Bottleneck");

  Local = class Local {
    constructor(instance) {
      this.instance = instance;
      this._queues = function() {
        return this.instance._queues;
      };
      this._reservoir = this.instance.reservoir;
      this._nextRequest = Date.now();
      this._running = 0;
      this._unblockTime = 0;
    }

    __running__() {
      return this._running;
    }

    __globalQueued__() {
      return this._queues().reduce((function(a, b) {
        return a + b.length;
      }), 0);
    }

    conditionsCheck(maxConcurrent, reservoirEnabled, weight) {
      return ((maxConcurrent == null) || this._running + weight <= maxConcurrent) && (!reservoirEnabled || this._reservoir - weight >= 0);
    }

    __isBlocked__(now) {
      return this._unblockTime >= now;
    }

    __check__(weight, reservoirEnabled, now, maxConcurrent) {
      return this.conditionsCheck(maxConcurrent, reservoirEnabled, weight) && (this._nextRequest - now) <= 0;
    }

    __register__(weight, reservoirEnabled, now, maxConcurrent, minTime) {
      var wait;
      if (this.conditionsCheck(maxConcurrent, reservoirEnabled, weight)) {
        this._running += weight;
        if (reservoirEnabled) {
          this._reservoir -= weight;
        }
        wait = Math.max(this._nextRequest - now, 0);
        this._nextRequest = now + wait + minTime;
        return {
          success: true,
          wait,
          reservoir: this._reservoir
        };
      } else {
        return {
          success: false
        };
      }
    }

    __submit__(strategyIsBlock, penalty, reservoirEnabled, highwaterEnabled, queueMaxed, weight, now, maxConcurrent, minTime) {
      var blocked, check, reachedHighWaterMark;
      check = this.__check__(weight, reservoirEnabled, now, maxConcurrent);
      reachedHighWaterMark = highwaterEnabled && queueMaxed && !check;
      blocked = strategyIsBlock && (reachedHighWaterMark || this.__isBlocked__(now));
      if (blocked) {
        this._unblockTime = now + penalty;
        this._nextRequest = this._unblockTime + minTime;
      }
      return {reachedHighWaterMark, blocked};
    }

    __free__(weight) {
      this._running -= weight;
      return {
        running: this._running,
        queued: this.__globalQueued__()
      };
    }

  };

  module.exports = Local;

}).call(this);
